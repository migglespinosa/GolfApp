{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : (global = global || self, global.Delaunator = factory());\n})(this, function () {\n  'use strict';\n\n  var EPSILON = Math.pow(2, -52);\n  var EDGE_STACK = new Uint32Array(512);\n\n  var Delaunator = function Delaunator(coords) {\n    var n = coords.length >> 1;\n\n    if (n > 0 && typeof coords[0] !== 'number') {\n      throw new Error('Expected coords to contain numbers.');\n    }\n\n    this.coords = coords; // arrays that will store the triangulation graph\n\n    var maxTriangles = Math.max(2 * n - 5, 0);\n    this._triangles = new Uint32Array(maxTriangles * 3);\n    this._halfedges = new Int32Array(maxTriangles * 3); // temporary arrays for tracking the edges of the advancing convex hull\n\n    this._hashSize = Math.ceil(Math.sqrt(n));\n    this._hullPrev = new Uint32Array(n); // edge to prev edge\n\n    this._hullNext = new Uint32Array(n); // edge to next edge\n\n    this._hullTri = new Uint32Array(n); // edge to adjacent triangle\n\n    this._hullHash = new Int32Array(this._hashSize).fill(-1); // angular edge hash\n    // temporary arrays for sorting points\n\n    this._ids = new Uint32Array(n);\n    this._dists = new Float64Array(n);\n    this.update();\n  };\n\n  Delaunator.from = function from(points, getX, getY) {\n    if (getX === void 0) getX = defaultGetX;\n    if (getY === void 0) getY = defaultGetY;\n    var n = points.length;\n    var coords = new Float64Array(n * 2);\n\n    for (var i = 0; i < n; i++) {\n      var p = points[i];\n      coords[2 * i] = getX(p);\n      coords[2 * i + 1] = getY(p);\n    }\n\n    return new Delaunator(coords);\n  };\n\n  Delaunator.prototype.update = function update() {\n    var ref = this;\n    var coords = ref.coords;\n    var hullPrev = ref._hullPrev;\n    var hullNext = ref._hullNext;\n    var hullTri = ref._hullTri;\n    var hullHash = ref._hullHash;\n    var n = coords.length >> 1; // populate an array of point indices; calculate input data bbox\n\n    var minX = Infinity;\n    var minY = Infinity;\n    var maxX = -Infinity;\n    var maxY = -Infinity;\n\n    for (var i = 0; i < n; i++) {\n      var x = coords[2 * i];\n      var y = coords[2 * i + 1];\n\n      if (x < minX) {\n        minX = x;\n      }\n\n      if (y < minY) {\n        minY = y;\n      }\n\n      if (x > maxX) {\n        maxX = x;\n      }\n\n      if (y > maxY) {\n        maxY = y;\n      }\n\n      this._ids[i] = i;\n    }\n\n    var cx = (minX + maxX) / 2;\n    var cy = (minY + maxY) / 2;\n    var minDist = Infinity;\n    var i0, i1, i2; // pick a seed point close to the center\n\n    for (var i$1 = 0; i$1 < n; i$1++) {\n      var d = dist(cx, cy, coords[2 * i$1], coords[2 * i$1 + 1]);\n\n      if (d < minDist) {\n        i0 = i$1;\n        minDist = d;\n      }\n    }\n\n    var i0x = coords[2 * i0];\n    var i0y = coords[2 * i0 + 1];\n    minDist = Infinity; // find the point closest to the seed\n\n    for (var i$2 = 0; i$2 < n; i$2++) {\n      if (i$2 === i0) {\n        continue;\n      }\n\n      var d$1 = dist(i0x, i0y, coords[2 * i$2], coords[2 * i$2 + 1]);\n\n      if (d$1 < minDist && d$1 > 0) {\n        i1 = i$2;\n        minDist = d$1;\n      }\n    }\n\n    var i1x = coords[2 * i1];\n    var i1y = coords[2 * i1 + 1];\n    var minRadius = Infinity; // find the third point which forms the smallest circumcircle with the first two\n\n    for (var i$3 = 0; i$3 < n; i$3++) {\n      if (i$3 === i0 || i$3 === i1) {\n        continue;\n      }\n\n      var r = circumradius(i0x, i0y, i1x, i1y, coords[2 * i$3], coords[2 * i$3 + 1]);\n\n      if (r < minRadius) {\n        i2 = i$3;\n        minRadius = r;\n      }\n    }\n\n    var i2x = coords[2 * i2];\n    var i2y = coords[2 * i2 + 1];\n\n    if (minRadius === Infinity) {\n      // order collinear points by dx (or dy if all x are identical)\n      // and return the list as a hull\n      for (var i$4 = 0; i$4 < n; i$4++) {\n        this._dists[i$4] = coords[2 * i$4] - coords[0] || coords[2 * i$4 + 1] - coords[1];\n      }\n\n      quicksort(this._ids, this._dists, 0, n - 1);\n      var hull = new Uint32Array(n);\n      var j = 0;\n\n      for (var i$5 = 0, d0 = -Infinity; i$5 < n; i$5++) {\n        var id = this._ids[i$5];\n\n        if (this._dists[id] > d0) {\n          hull[j++] = id;\n          d0 = this._dists[id];\n        }\n      }\n\n      this.hull = hull.subarray(0, j);\n      this.triangles = new Uint32Array(0);\n      this.halfedges = new Uint32Array(0);\n      return;\n    } // swap the order of the seed points for counter-clockwise orientation\n\n\n    if (orient(i0x, i0y, i1x, i1y, i2x, i2y)) {\n      var i$6 = i1;\n      var x$1 = i1x;\n      var y$1 = i1y;\n      i1 = i2;\n      i1x = i2x;\n      i1y = i2y;\n      i2 = i$6;\n      i2x = x$1;\n      i2y = y$1;\n    }\n\n    var center = circumcenter(i0x, i0y, i1x, i1y, i2x, i2y);\n    this._cx = center.x;\n    this._cy = center.y;\n\n    for (var i$7 = 0; i$7 < n; i$7++) {\n      this._dists[i$7] = dist(coords[2 * i$7], coords[2 * i$7 + 1], center.x, center.y);\n    } // sort the points by distance from the seed triangle circumcenter\n\n\n    quicksort(this._ids, this._dists, 0, n - 1); // set up the seed triangle as the starting hull\n\n    this._hullStart = i0;\n    var hullSize = 3;\n    hullNext[i0] = hullPrev[i2] = i1;\n    hullNext[i1] = hullPrev[i0] = i2;\n    hullNext[i2] = hullPrev[i1] = i0;\n    hullTri[i0] = 0;\n    hullTri[i1] = 1;\n    hullTri[i2] = 2;\n    hullHash.fill(-1);\n    hullHash[this._hashKey(i0x, i0y)] = i0;\n    hullHash[this._hashKey(i1x, i1y)] = i1;\n    hullHash[this._hashKey(i2x, i2y)] = i2;\n    this.trianglesLen = 0;\n\n    this._addTriangle(i0, i1, i2, -1, -1, -1);\n\n    for (var k = 0, xp = void 0, yp = void 0; k < this._ids.length; k++) {\n      var i$8 = this._ids[k];\n      var x$2 = coords[2 * i$8];\n      var y$2 = coords[2 * i$8 + 1]; // skip near-duplicate points\n\n      if (k > 0 && Math.abs(x$2 - xp) <= EPSILON && Math.abs(y$2 - yp) <= EPSILON) {\n        continue;\n      }\n\n      xp = x$2;\n      yp = y$2; // skip seed triangle points\n\n      if (i$8 === i0 || i$8 === i1 || i$8 === i2) {\n        continue;\n      } // find a visible edge on the convex hull using edge hash\n\n\n      var start = 0;\n\n      for (var j$1 = 0, key = this._hashKey(x$2, y$2); j$1 < this._hashSize; j$1++) {\n        start = hullHash[(key + j$1) % this._hashSize];\n\n        if (start !== -1 && start !== hullNext[start]) {\n          break;\n        }\n      }\n\n      start = hullPrev[start];\n      var e = start,\n          q = void 0;\n\n      while (q = hullNext[e], !orient(x$2, y$2, coords[2 * e], coords[2 * e + 1], coords[2 * q], coords[2 * q + 1])) {\n        e = q;\n\n        if (e === start) {\n          e = -1;\n          break;\n        }\n      }\n\n      if (e === -1) {\n        continue;\n      } // likely a near-duplicate point; skip it\n      // add the first triangle from the point\n\n\n      var t = this._addTriangle(e, i$8, hullNext[e], -1, -1, hullTri[e]); // recursively flip triangles from the point until they satisfy the Delaunay condition\n\n\n      hullTri[i$8] = this._legalize(t + 2);\n      hullTri[e] = t; // keep track of boundary triangles on the hull\n\n      hullSize++; // walk forward through the hull, adding more triangles and flipping recursively\n\n      var n$1 = hullNext[e];\n\n      while (q = hullNext[n$1], orient(x$2, y$2, coords[2 * n$1], coords[2 * n$1 + 1], coords[2 * q], coords[2 * q + 1])) {\n        t = this._addTriangle(n$1, i$8, q, hullTri[i$8], -1, hullTri[n$1]);\n        hullTri[i$8] = this._legalize(t + 2);\n        hullNext[n$1] = n$1; // mark as removed\n\n        hullSize--;\n        n$1 = q;\n      } // walk backward from the other side, adding more triangles and flipping\n\n\n      if (e === start) {\n        while (q = hullPrev[e], orient(x$2, y$2, coords[2 * q], coords[2 * q + 1], coords[2 * e], coords[2 * e + 1])) {\n          t = this._addTriangle(q, i$8, e, -1, hullTri[e], hullTri[q]);\n\n          this._legalize(t + 2);\n\n          hullTri[q] = t;\n          hullNext[e] = e; // mark as removed\n\n          hullSize--;\n          e = q;\n        }\n      } // update the hull indices\n\n\n      this._hullStart = hullPrev[i$8] = e;\n      hullNext[e] = hullPrev[n$1] = i$8;\n      hullNext[i$8] = n$1; // save the two new edges in the hash table\n\n      hullHash[this._hashKey(x$2, y$2)] = i$8;\n      hullHash[this._hashKey(coords[2 * e], coords[2 * e + 1])] = e;\n    }\n\n    this.hull = new Uint32Array(hullSize);\n\n    for (var i$9 = 0, e$1 = this._hullStart; i$9 < hullSize; i$9++) {\n      this.hull[i$9] = e$1;\n      e$1 = hullNext[e$1];\n    } // trim typed triangle mesh arrays\n\n\n    this.triangles = this._triangles.subarray(0, this.trianglesLen);\n    this.halfedges = this._halfedges.subarray(0, this.trianglesLen);\n  };\n\n  Delaunator.prototype._hashKey = function _hashKey(x, y) {\n    return Math.floor(pseudoAngle(x - this._cx, y - this._cy) * this._hashSize) % this._hashSize;\n  };\n\n  Delaunator.prototype._legalize = function _legalize(a) {\n    var ref = this;\n    var triangles = ref._triangles;\n    var halfedges = ref._halfedges;\n    var coords = ref.coords;\n    var i = 0;\n    var ar = 0; // recursion eliminated with a fixed-size stack\n\n    while (true) {\n      var b = halfedges[a];\n      /* if the pair of triangles doesn't satisfy the Delaunay condition\n       * (p1 is inside the circumcircle of [p0, pl, pr]), flip them,\n       * then do the same check/flip recursively for the new pair of triangles\n       *\n       *       pl                pl\n       *      /||\\              /  \\\n       *   al/ || \\bl        al/\\a\n       *    /  ||  \\          /  \\\n       *   /  a||b  \\flip/___ar___\\\n       * p0\\   ||   /p1   =>   p0\\---bl---/p1\n       *    \\  ||  /          \\  /\n       *   ar\\ || /br         b\\/br\n       *      \\||/              \\  /\n       *       pr                pr\n       */\n\n      var a0 = a - a % 3;\n      ar = a0 + (a + 2) % 3;\n\n      if (b === -1) {\n        // convex hull edge\n        if (i === 0) {\n          break;\n        }\n\n        a = EDGE_STACK[--i];\n        continue;\n      }\n\n      var b0 = b - b % 3;\n      var al = a0 + (a + 1) % 3;\n      var bl = b0 + (b + 2) % 3;\n      var p0 = triangles[ar];\n      var pr = triangles[a];\n      var pl = triangles[al];\n      var p1 = triangles[bl];\n      var illegal = inCircle(coords[2 * p0], coords[2 * p0 + 1], coords[2 * pr], coords[2 * pr + 1], coords[2 * pl], coords[2 * pl + 1], coords[2 * p1], coords[2 * p1 + 1]);\n\n      if (illegal) {\n        triangles[a] = p1;\n        triangles[b] = p0;\n        var hbl = halfedges[bl]; // edge swapped on the other side of the hull (rare); fix the halfedge reference\n\n        if (hbl === -1) {\n          var e = this._hullStart;\n\n          do {\n            if (this._hullTri[e] === bl) {\n              this._hullTri[e] = a;\n              break;\n            }\n\n            e = this._hullPrev[e];\n          } while (e !== this._hullStart);\n        }\n\n        this._link(a, hbl);\n\n        this._link(b, halfedges[ar]);\n\n        this._link(ar, bl);\n\n        var br = b0 + (b + 1) % 3; // don't worry about hitting the cap: it can only happen on extremely degenerate input\n\n        if (i < EDGE_STACK.length) {\n          EDGE_STACK[i++] = br;\n        }\n      } else {\n        if (i === 0) {\n          break;\n        }\n\n        a = EDGE_STACK[--i];\n      }\n    }\n\n    return ar;\n  };\n\n  Delaunator.prototype._link = function _link(a, b) {\n    this._halfedges[a] = b;\n\n    if (b !== -1) {\n      this._halfedges[b] = a;\n    }\n  }; // add a new triangle given vertex indices and adjacent half-edge ids\n\n\n  Delaunator.prototype._addTriangle = function _addTriangle(i0, i1, i2, a, b, c) {\n    var t = this.trianglesLen;\n    this._triangles[t] = i0;\n    this._triangles[t + 1] = i1;\n    this._triangles[t + 2] = i2;\n\n    this._link(t, a);\n\n    this._link(t + 1, b);\n\n    this._link(t + 2, c);\n\n    this.trianglesLen += 3;\n    return t;\n  }; // monotonically increases with real angle, but doesn't need expensive trigonometry\n\n\n  function pseudoAngle(dx, dy) {\n    var p = dx / (Math.abs(dx) + Math.abs(dy));\n    return (dy > 0 ? 3 - p : 1 + p) / 4; // [0..1]\n  }\n\n  function dist(ax, ay, bx, by) {\n    var dx = ax - bx;\n    var dy = ay - by;\n    return dx * dx + dy * dy;\n  } // return 2d orientation sign if we're confident in it through J. Shewchuk's error bound check\n\n\n  function orientIfSure(px, py, rx, ry, qx, qy) {\n    var l = (ry - py) * (qx - px);\n    var r = (rx - px) * (qy - py);\n    return Math.abs(l - r) >= 3.3306690738754716e-16 * Math.abs(l + r) ? l - r : 0;\n  } // a more robust orientation test that's stable in a given triangle (to fix robustness issues)\n\n\n  function orient(rx, ry, qx, qy, px, py) {\n    var sign = orientIfSure(px, py, rx, ry, qx, qy) || orientIfSure(rx, ry, qx, qy, px, py) || orientIfSure(qx, qy, px, py, rx, ry);\n    return sign < 0;\n  }\n\n  function inCircle(ax, ay, bx, by, cx, cy, px, py) {\n    var dx = ax - px;\n    var dy = ay - py;\n    var ex = bx - px;\n    var ey = by - py;\n    var fx = cx - px;\n    var fy = cy - py;\n    var ap = dx * dx + dy * dy;\n    var bp = ex * ex + ey * ey;\n    var cp = fx * fx + fy * fy;\n    return dx * (ey * cp - bp * fy) - dy * (ex * cp - bp * fx) + ap * (ex * fy - ey * fx) < 0;\n  }\n\n  function circumradius(ax, ay, bx, by, cx, cy) {\n    var dx = bx - ax;\n    var dy = by - ay;\n    var ex = cx - ax;\n    var ey = cy - ay;\n    var bl = dx * dx + dy * dy;\n    var cl = ex * ex + ey * ey;\n    var d = 0.5 / (dx * ey - dy * ex);\n    var x = (ey * bl - dy * cl) * d;\n    var y = (dx * cl - ex * bl) * d;\n    return x * x + y * y;\n  }\n\n  function circumcenter(ax, ay, bx, by, cx, cy) {\n    var dx = bx - ax;\n    var dy = by - ay;\n    var ex = cx - ax;\n    var ey = cy - ay;\n    var bl = dx * dx + dy * dy;\n    var cl = ex * ex + ey * ey;\n    var d = 0.5 / (dx * ey - dy * ex);\n    var x = ax + (ey * bl - dy * cl) * d;\n    var y = ay + (dx * cl - ex * bl) * d;\n    return {\n      x: x,\n      y: y\n    };\n  }\n\n  function quicksort(ids, dists, left, right) {\n    if (right - left <= 20) {\n      for (var i = left + 1; i <= right; i++) {\n        var temp = ids[i];\n        var tempDist = dists[temp];\n        var j = i - 1;\n\n        while (j >= left && dists[ids[j]] > tempDist) {\n          ids[j + 1] = ids[j--];\n        }\n\n        ids[j + 1] = temp;\n      }\n    } else {\n      var median = left + right >> 1;\n      var i$1 = left + 1;\n      var j$1 = right;\n      swap(ids, median, i$1);\n\n      if (dists[ids[left]] > dists[ids[right]]) {\n        swap(ids, left, right);\n      }\n\n      if (dists[ids[i$1]] > dists[ids[right]]) {\n        swap(ids, i$1, right);\n      }\n\n      if (dists[ids[left]] > dists[ids[i$1]]) {\n        swap(ids, left, i$1);\n      }\n\n      var temp$1 = ids[i$1];\n      var tempDist$1 = dists[temp$1];\n\n      while (true) {\n        do {\n          i$1++;\n        } while (dists[ids[i$1]] < tempDist$1);\n\n        do {\n          j$1--;\n        } while (dists[ids[j$1]] > tempDist$1);\n\n        if (j$1 < i$1) {\n          break;\n        }\n\n        swap(ids, i$1, j$1);\n      }\n\n      ids[left + 1] = ids[j$1];\n      ids[j$1] = temp$1;\n\n      if (right - i$1 + 1 >= j$1 - left) {\n        quicksort(ids, dists, i$1, right);\n        quicksort(ids, dists, left, j$1 - 1);\n      } else {\n        quicksort(ids, dists, left, j$1 - 1);\n        quicksort(ids, dists, i$1, right);\n      }\n    }\n  }\n\n  function swap(arr, i, j) {\n    var tmp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = tmp;\n  }\n\n  function defaultGetX(p) {\n    return p[0];\n  }\n\n  function defaultGetY(p) {\n    return p[1];\n  }\n\n  return Delaunator;\n});","map":null,"metadata":{},"sourceType":"script"}